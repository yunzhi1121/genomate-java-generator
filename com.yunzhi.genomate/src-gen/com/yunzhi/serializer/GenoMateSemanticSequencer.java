/*
 * generated by Xtext 2.38.0
 */
package com.yunzhi.serializer;

import com.google.inject.Inject;
import com.yunzhi.genoMate.AndTypeCondition;
import com.yunzhi.genoMate.AnnotationParameters;
import com.yunzhi.genoMate.ArrayType;
import com.yunzhi.genoMate.BeanValidationAnnotation;
import com.yunzhi.genoMate.DTOToModelMapping;
import com.yunzhi.genoMate.DtoAddField;
import com.yunzhi.genoMate.DtoDefinition;
import com.yunzhi.genoMate.DtoRule;
import com.yunzhi.genoMate.DtoValidation;
import com.yunzhi.genoMate.Exclusions;
import com.yunzhi.genoMate.Field;
import com.yunzhi.genoMate.FieldAnnotation;
import com.yunzhi.genoMate.FieldValidationBlock;
import com.yunzhi.genoMate.GenerateSection;
import com.yunzhi.genoMate.GenericDataType;
import com.yunzhi.genoMate.GenoMate;
import com.yunzhi.genoMate.GenoMatePackage;
import com.yunzhi.genoMate.GlobalAction;
import com.yunzhi.genoMate.GlobalConfig;
import com.yunzhi.genoMate.JacksonAnnotation;
import com.yunzhi.genoMate.LocalAction;
import com.yunzhi.genoMate.LocalLoopAction;
import com.yunzhi.genoMate.LombokAnnotation;
import com.yunzhi.genoMate.MappingRule;
import com.yunzhi.genoMate.Model;
import com.yunzhi.genoMate.ModelToVOMapping;
import com.yunzhi.genoMate.MybatisPlusFieldAnnotation;
import com.yunzhi.genoMate.MybatisPlusModelAnnotation;
import com.yunzhi.genoMate.NormalType;
import com.yunzhi.genoMate.OrTypeCondition;
import com.yunzhi.genoMate.PoAddField;
import com.yunzhi.genoMate.PoRule;
import com.yunzhi.genoMate.PropertyDeclaration;
import com.yunzhi.genoMate.SimpleType;
import com.yunzhi.genoMate.SingleAction;
import com.yunzhi.genoMate.TypeEqualityCondition;
import com.yunzhi.genoMate.VariableDeclaration;
import com.yunzhi.genoMate.VoAddField;
import com.yunzhi.genoMate.VoDefinition;
import com.yunzhi.genoMate.VoJackson;
import com.yunzhi.genoMate.VoRule;
import com.yunzhi.services.GenoMateGrammarAccess;
import java.util.Set;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Parameter;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.serializer.ISerializationContext;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.sequencer.AbstractDelegatingSemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;

@SuppressWarnings("all")
public class GenoMateSemanticSequencer extends AbstractDelegatingSemanticSequencer {

	@Inject
	private GenoMateGrammarAccess grammarAccess;
	
	@Override
	public void sequence(ISerializationContext context, EObject semanticObject) {
		EPackage epackage = semanticObject.eClass().getEPackage();
		ParserRule rule = context.getParserRule();
		Action action = context.getAssignedAction();
		Set<Parameter> parameters = context.getEnabledBooleanParameters();
		if (epackage == GenoMatePackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case GenoMatePackage.AND_TYPE_CONDITION:
				sequence_AndTypeCondition(context, (AndTypeCondition) semanticObject); 
				return; 
			case GenoMatePackage.ANNOTATION_PARAMETERS:
				sequence_AnnotationParameters(context, (AnnotationParameters) semanticObject); 
				return; 
			case GenoMatePackage.ARRAY_TYPE:
				sequence_ArrayType(context, (ArrayType) semanticObject); 
				return; 
			case GenoMatePackage.BEAN_VALIDATION_ANNOTATION:
				sequence_BeanValidationAnnotation(context, (BeanValidationAnnotation) semanticObject); 
				return; 
			case GenoMatePackage.DTO_TO_MODEL_MAPPING:
				sequence_DTOToModelMapping(context, (DTOToModelMapping) semanticObject); 
				return; 
			case GenoMatePackage.DTO_ADD_FIELD:
				sequence_DtoAddField(context, (DtoAddField) semanticObject); 
				return; 
			case GenoMatePackage.DTO_DEFINITION:
				sequence_DtoDefinition(context, (DtoDefinition) semanticObject); 
				return; 
			case GenoMatePackage.DTO_RULE:
				sequence_DtoRule(context, (DtoRule) semanticObject); 
				return; 
			case GenoMatePackage.DTO_VALIDATION:
				sequence_DtoValidation(context, (DtoValidation) semanticObject); 
				return; 
			case GenoMatePackage.EXCLUSIONS:
				sequence_Exclusions(context, (Exclusions) semanticObject); 
				return; 
			case GenoMatePackage.FIELD:
				sequence_Field(context, (Field) semanticObject); 
				return; 
			case GenoMatePackage.FIELD_ANNOTATION:
				sequence_FieldAnnotation(context, (FieldAnnotation) semanticObject); 
				return; 
			case GenoMatePackage.FIELD_VALIDATION_BLOCK:
				sequence_FieldValidationBlock(context, (FieldValidationBlock) semanticObject); 
				return; 
			case GenoMatePackage.GENERATE_SECTION:
				sequence_GenerateSection(context, (GenerateSection) semanticObject); 
				return; 
			case GenoMatePackage.GENERIC_DATA_TYPE:
				sequence_GenericDataType(context, (GenericDataType) semanticObject); 
				return; 
			case GenoMatePackage.GENO_MATE:
				sequence_GenoMate(context, (GenoMate) semanticObject); 
				return; 
			case GenoMatePackage.GLOBAL_ACTION:
				sequence_GlobalAction(context, (GlobalAction) semanticObject); 
				return; 
			case GenoMatePackage.GLOBAL_CONFIG:
				sequence_GlobalConfig(context, (GlobalConfig) semanticObject); 
				return; 
			case GenoMatePackage.JACKSON_ANNOTATION:
				sequence_JacksonAnnotation(context, (JacksonAnnotation) semanticObject); 
				return; 
			case GenoMatePackage.LOCAL_ACTION:
				sequence_LocalAction(context, (LocalAction) semanticObject); 
				return; 
			case GenoMatePackage.LOCAL_LOOP_ACTION:
				sequence_LocalLoopAction(context, (LocalLoopAction) semanticObject); 
				return; 
			case GenoMatePackage.LOMBOK_ANNOTATION:
				sequence_LombokAnnotation(context, (LombokAnnotation) semanticObject); 
				return; 
			case GenoMatePackage.MAPPING_RULE:
				sequence_MappingRule(context, (MappingRule) semanticObject); 
				return; 
			case GenoMatePackage.MODEL:
				sequence_Model(context, (Model) semanticObject); 
				return; 
			case GenoMatePackage.MODEL_TO_VO_MAPPING:
				sequence_ModelToVOMapping(context, (ModelToVOMapping) semanticObject); 
				return; 
			case GenoMatePackage.MYBATIS_PLUS_FIELD_ANNOTATION:
				sequence_MybatisPlusFieldAnnotation(context, (MybatisPlusFieldAnnotation) semanticObject); 
				return; 
			case GenoMatePackage.MYBATIS_PLUS_MODEL_ANNOTATION:
				sequence_MybatisPlusModelAnnotation(context, (MybatisPlusModelAnnotation) semanticObject); 
				return; 
			case GenoMatePackage.NORMAL_TYPE:
				sequence_NormalType(context, (NormalType) semanticObject); 
				return; 
			case GenoMatePackage.OR_TYPE_CONDITION:
				sequence_OrTypeCondition(context, (OrTypeCondition) semanticObject); 
				return; 
			case GenoMatePackage.PARAMETER:
				sequence_Parameter(context, (com.yunzhi.genoMate.Parameter) semanticObject); 
				return; 
			case GenoMatePackage.PO_ADD_FIELD:
				sequence_PoAddField(context, (PoAddField) semanticObject); 
				return; 
			case GenoMatePackage.PO_RULE:
				sequence_PoRule(context, (PoRule) semanticObject); 
				return; 
			case GenoMatePackage.PROPERTY_DECLARATION:
				sequence_PropertyDeclaration(context, (PropertyDeclaration) semanticObject); 
				return; 
			case GenoMatePackage.SIMPLE_TYPE:
				sequence_SimpleType(context, (SimpleType) semanticObject); 
				return; 
			case GenoMatePackage.SINGLE_ACTION:
				sequence_SingleAction(context, (SingleAction) semanticObject); 
				return; 
			case GenoMatePackage.TYPE_EQUALITY_CONDITION:
				sequence_TypeEqualityCondition(context, (TypeEqualityCondition) semanticObject); 
				return; 
			case GenoMatePackage.VARIABLE_DECLARATION:
				sequence_VariableDeclaration(context, (VariableDeclaration) semanticObject); 
				return; 
			case GenoMatePackage.VO_ADD_FIELD:
				sequence_VoAddField(context, (VoAddField) semanticObject); 
				return; 
			case GenoMatePackage.VO_DEFINITION:
				sequence_VoDefinition(context, (VoDefinition) semanticObject); 
				return; 
			case GenoMatePackage.VO_JACKSON:
				sequence_VoJackson(context, (VoJackson) semanticObject); 
				return; 
			case GenoMatePackage.VO_RULE:
				sequence_VoRule(context, (VoRule) semanticObject); 
				return; 
			}
		if (errorAcceptor != null)
			errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * <pre>
	 * Contexts:
	 *     AndTypeCondition returns AndTypeCondition
	 *
	 * Constraint:
	 *     (left=TypeEqualityCondition right+=TypeEqualityCondition*)
	 * </pre>
	 */
	protected void sequence_AndTypeCondition(ISerializationContext context, AndTypeCondition semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     AnnotationParameters returns AnnotationParameters
	 *
	 * Constraint:
	 *     (annparameters+=Parameter parameters+=Parameter*)
	 * </pre>
	 */
	protected void sequence_AnnotationParameters(ISerializationContext context, AnnotationParameters semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Type returns ArrayType
	 *     ArrayType returns ArrayType
	 *
	 * Constraint:
	 *     (elementType=SimpleType | elementType=NormalType)
	 * </pre>
	 */
	protected void sequence_ArrayType(ISerializationContext context, ArrayType semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     BeanValidationAnnotation returns BeanValidationAnnotation
	 *
	 * Constraint:
	 *     (name=BeanValidationType parameters=AnnotationParameters?)
	 * </pre>
	 */
	protected void sequence_BeanValidationAnnotation(ISerializationContext context, BeanValidationAnnotation semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Mapping returns DTOToModelMapping
	 *     DTOToModelMapping returns DTOToModelMapping
	 *
	 * Constraint:
	 *     (source=[DtoDefinition|ID] target=[Model|ID] rules+=MappingRule*)
	 * </pre>
	 */
	protected void sequence_DTOToModelMapping(ISerializationContext context, DTOToModelMapping semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     DtoAddField returns DtoAddField
	 *
	 * Constraint:
	 *     (properties=PropertyDeclaration annotationList+=BeanValidationAnnotation*)
	 * </pre>
	 */
	protected void sequence_DtoAddField(ISerializationContext context, DtoAddField semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     DtoDefinition returns DtoDefinition
	 *
	 * Constraint:
	 *     (
	 *         name=ID 
	 *         serializable='Serializable'? 
	 *         lombokAnnotation+=LombokAnnotation* 
	 *         (exclusions+=Exclusions+ | excludeAll=BOOL)? 
	 *         fieldAnnotationsBlock=FieldValidationBlock? 
	 *         addField+=DtoAddField*
	 *     )
	 * </pre>
	 */
	protected void sequence_DtoDefinition(ISerializationContext context, DtoDefinition semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     GenerationRule returns DtoRule
	 *     DtoRule returns DtoRule
	 *
	 * Constraint:
	 *     (model=[Model|ID] dtos+=DtoDefinition+)
	 * </pre>
	 */
	protected void sequence_DtoRule(ISerializationContext context, DtoRule semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     DtoValidation returns DtoValidation
	 *
	 * Constraint:
	 *     (field=[Field|QualifiedName] annList+=BeanValidationAnnotation*)
	 * </pre>
	 */
	protected void sequence_DtoValidation(ISerializationContext context, DtoValidation semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Exclusions returns Exclusions
	 *
	 * Constraint:
	 *     field=[Field|QualifiedName]
	 * </pre>
	 */
	protected void sequence_Exclusions(ISerializationContext context, Exclusions semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, GenoMatePackage.Literals.EXCLUSIONS__FIELD) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, GenoMatePackage.Literals.EXCLUSIONS__FIELD));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getExclusionsAccess().getFieldFieldQualifiedNameParserRuleCall_1_0_1(), semanticObject.eGet(GenoMatePackage.Literals.EXCLUSIONS__FIELD, false));
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     FieldAnnotation returns FieldAnnotation
	 *
	 * Constraint:
	 *     (field=[Field|QualifiedName] annList+=MybatisPlusFieldAnnotation*)
	 * </pre>
	 */
	protected void sequence_FieldAnnotation(ISerializationContext context, FieldAnnotation semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     FieldValidationBlock returns FieldValidationBlock
	 *
	 * Constraint:
	 *     (actionGlobal+=GlobalAction* actionLocal+=LocalLoopAction* actionSingle=SingleAction?)
	 * </pre>
	 */
	protected void sequence_FieldValidationBlock(ISerializationContext context, FieldValidationBlock semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Field returns Field
	 *
	 * Constraint:
	 *     (type=Type name=ID)
	 * </pre>
	 */
	protected void sequence_Field(ISerializationContext context, Field semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, GenoMatePackage.Literals.FIELD__TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, GenoMatePackage.Literals.FIELD__TYPE));
			if (transientValues.isValueTransient(semanticObject, GenoMatePackage.Literals.FIELD__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, GenoMatePackage.Literals.FIELD__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getFieldAccess().getTypeTypeParserRuleCall_0_0(), semanticObject.getType());
		feeder.accept(grammarAccess.getFieldAccess().getNameIDTerminalRuleCall_1_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     GenerateSection returns GenerateSection
	 *
	 * Constraint:
	 *     rules+=GenerationRule+
	 * </pre>
	 */
	protected void sequence_GenerateSection(ISerializationContext context, GenerateSection semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Type returns GenericDataType
	 *     GenericDataType returns GenericDataType
	 *
	 * Constraint:
	 *     (containerTypeName=ID containedTypeName=Type)
	 * </pre>
	 */
	protected void sequence_GenericDataType(ISerializationContext context, GenericDataType semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, GenoMatePackage.Literals.GENERIC_DATA_TYPE__CONTAINER_TYPE_NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, GenoMatePackage.Literals.GENERIC_DATA_TYPE__CONTAINER_TYPE_NAME));
			if (transientValues.isValueTransient(semanticObject, GenoMatePackage.Literals.GENERIC_DATA_TYPE__CONTAINED_TYPE_NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, GenoMatePackage.Literals.GENERIC_DATA_TYPE__CONTAINED_TYPE_NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getGenericDataTypeAccess().getContainerTypeNameIDTerminalRuleCall_0_0(), semanticObject.getContainerTypeName());
		feeder.accept(grammarAccess.getGenericDataTypeAccess().getContainedTypeNameTypeParserRuleCall_2_0(), semanticObject.getContainedTypeName());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     GenoMate returns GenoMate
	 *
	 * Constraint:
	 *     (globalConfig=GlobalConfig? model=Model generateSection=GenerateSection mappings+=Mapping*)
	 * </pre>
	 */
	protected void sequence_GenoMate(ISerializationContext context, GenoMate semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     GlobalAction returns GlobalAction
	 *
	 * Constraint:
	 *     variable=[VariableDeclaration|ID]
	 * </pre>
	 */
	protected void sequence_GlobalAction(ISerializationContext context, GlobalAction semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, GenoMatePackage.Literals.GLOBAL_ACTION__VARIABLE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, GenoMatePackage.Literals.GLOBAL_ACTION__VARIABLE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getGlobalActionAccess().getVariableVariableDeclarationIDTerminalRuleCall_3_0_1(), semanticObject.eGet(GenoMatePackage.Literals.GLOBAL_ACTION__VARIABLE, false));
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     GlobalConfig returns GlobalConfig
	 *
	 * Constraint:
	 *     (package=STRING varDefaultAnnotations+=VariableDeclaration*)
	 * </pre>
	 */
	protected void sequence_GlobalConfig(ISerializationContext context, GlobalConfig semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     JacksonAnnotation returns JacksonAnnotation
	 *
	 * Constraint:
	 *     (name=JacksonType parameters=AnnotationParameters?)
	 * </pre>
	 */
	protected void sequence_JacksonAnnotation(ISerializationContext context, JacksonAnnotation semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     LocalAction returns LocalAction
	 *
	 * Constraint:
	 *     (condition=TypeCondition variable=[VariableDeclaration|ID])
	 * </pre>
	 */
	protected void sequence_LocalAction(ISerializationContext context, LocalAction semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, GenoMatePackage.Literals.LOCAL_ACTION__CONDITION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, GenoMatePackage.Literals.LOCAL_ACTION__CONDITION));
			if (transientValues.isValueTransient(semanticObject, GenoMatePackage.Literals.LOCAL_ACTION__VARIABLE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, GenoMatePackage.Literals.LOCAL_ACTION__VARIABLE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getLocalActionAccess().getConditionTypeConditionParserRuleCall_2_0(), semanticObject.getCondition());
		feeder.accept(grammarAccess.getLocalActionAccess().getVariableVariableDeclarationIDTerminalRuleCall_6_0_1(), semanticObject.eGet(GenoMatePackage.Literals.LOCAL_ACTION__VARIABLE, false));
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     LocalLoopAction returns LocalLoopAction
	 *
	 * Constraint:
	 *     (varDeclarations+=VariableDeclaration* actions+=LocalAction+)
	 * </pre>
	 */
	protected void sequence_LocalLoopAction(ISerializationContext context, LocalLoopAction semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     LombokAnnotation returns LombokAnnotation
	 *
	 * Constraint:
	 *     (name=LombokType parameters=AnnotationParameters?)
	 * </pre>
	 */
	protected void sequence_LombokAnnotation(ISerializationContext context, LombokAnnotation semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     MappingRule returns MappingRule
	 *
	 * Constraint:
	 *     (targetField=[Field|QualifiedName] (sourceField=[Field|QualifiedName] | default=Literal))
	 * </pre>
	 */
	protected void sequence_MappingRule(ISerializationContext context, MappingRule semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Mapping returns ModelToVOMapping
	 *     ModelToVOMapping returns ModelToVOMapping
	 *
	 * Constraint:
	 *     (source=[Model|ID] target=[VoDefinition|ID] rules+=MappingRule*)
	 * </pre>
	 */
	protected void sequence_ModelToVOMapping(ISerializationContext context, ModelToVOMapping semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Model returns Model
	 *
	 * Constraint:
	 *     (name=ID fields+=Field*)
	 * </pre>
	 */
	protected void sequence_Model(ISerializationContext context, Model semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     MybatisPlusFieldAnnotation returns MybatisPlusFieldAnnotation
	 *
	 * Constraint:
	 *     (name=MybatisPlusFieldType parameters=AnnotationParameters?)
	 * </pre>
	 */
	protected void sequence_MybatisPlusFieldAnnotation(ISerializationContext context, MybatisPlusFieldAnnotation semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     MybatisPlusModelAnnotation returns MybatisPlusModelAnnotation
	 *
	 * Constraint:
	 *     (name=MybatisPlusModelType parameters=AnnotationParameters?)
	 * </pre>
	 */
	protected void sequence_MybatisPlusModelAnnotation(ISerializationContext context, MybatisPlusModelAnnotation semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Type returns NormalType
	 *     NormalType returns NormalType
	 *
	 * Constraint:
	 *     customType=ID
	 * </pre>
	 */
	protected void sequence_NormalType(ISerializationContext context, NormalType semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, GenoMatePackage.Literals.NORMAL_TYPE__CUSTOM_TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, GenoMatePackage.Literals.NORMAL_TYPE__CUSTOM_TYPE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getNormalTypeAccess().getCustomTypeIDTerminalRuleCall_0(), semanticObject.getCustomType());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     TypeCondition returns OrTypeCondition
	 *     OrTypeCondition returns OrTypeCondition
	 *
	 * Constraint:
	 *     (left=AndTypeCondition right+=AndTypeCondition*)
	 * </pre>
	 */
	protected void sequence_OrTypeCondition(ISerializationContext context, OrTypeCondition semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Parameter returns Parameter
	 *
	 * Constraint:
	 *     (key=ID value=Literal)
	 * </pre>
	 */
	protected void sequence_Parameter(ISerializationContext context, com.yunzhi.genoMate.Parameter semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, GenoMatePackage.Literals.PARAMETER__KEY) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, GenoMatePackage.Literals.PARAMETER__KEY));
			if (transientValues.isValueTransient(semanticObject, GenoMatePackage.Literals.PARAMETER__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, GenoMatePackage.Literals.PARAMETER__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getParameterAccess().getKeyIDTerminalRuleCall_0_0(), semanticObject.getKey());
		feeder.accept(grammarAccess.getParameterAccess().getValueLiteralParserRuleCall_2_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     PoAddField returns PoAddField
	 *
	 * Constraint:
	 *     (properties=PropertyDeclaration annotationList+=MybatisPlusFieldAnnotation*)
	 * </pre>
	 */
	protected void sequence_PoAddField(ISerializationContext context, PoAddField semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     GenerationRule returns PoRule
	 *     PoRule returns PoRule
	 *
	 * Constraint:
	 *     (
	 *         model=[Model|ID] 
	 *         serializable='Serializable'? 
	 *         lombokAnnotation+=LombokAnnotation* 
	 *         mybatisPlusModelAnnotation+=MybatisPlusModelAnnotation* 
	 *         fieldAnns+=FieldAnnotation* 
	 *         addField+=PoAddField*
	 *     )
	 * </pre>
	 */
	protected void sequence_PoRule(ISerializationContext context, PoRule semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     PropertyDeclaration returns PropertyDeclaration
	 *
	 * Constraint:
	 *     (static='static'? final='final'? type=Type name=ID defaultClause=DefaultClause?)
	 * </pre>
	 */
	protected void sequence_PropertyDeclaration(ISerializationContext context, PropertyDeclaration semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Type returns SimpleType
	 *     SimpleType returns SimpleType
	 *
	 * Constraint:
	 *     builtInType=BuiltInType
	 * </pre>
	 */
	protected void sequence_SimpleType(ISerializationContext context, SimpleType semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, GenoMatePackage.Literals.SIMPLE_TYPE__BUILT_IN_TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, GenoMatePackage.Literals.SIMPLE_TYPE__BUILT_IN_TYPE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getSimpleTypeAccess().getBuiltInTypeBuiltInTypeEnumRuleCall_0(), semanticObject.getBuiltInType());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     SingleAction returns SingleAction
	 *
	 * Constraint:
	 *     validations+=DtoValidation+
	 * </pre>
	 */
	protected void sequence_SingleAction(ISerializationContext context, SingleAction semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     TypeEqualityCondition returns TypeEqualityCondition
	 *
	 * Constraint:
	 *     ((isEqual='==' | isNotEqual='!=') type=Type)
	 * </pre>
	 */
	protected void sequence_TypeEqualityCondition(ISerializationContext context, TypeEqualityCondition semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     VariableDeclaration returns VariableDeclaration
	 *
	 * Constraint:
	 *     (name=ID annotation=BeanValidationAnnotation)
	 * </pre>
	 */
	protected void sequence_VariableDeclaration(ISerializationContext context, VariableDeclaration semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, GenoMatePackage.Literals.VARIABLE_DECLARATION__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, GenoMatePackage.Literals.VARIABLE_DECLARATION__NAME));
			if (transientValues.isValueTransient(semanticObject, GenoMatePackage.Literals.VARIABLE_DECLARATION__ANNOTATION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, GenoMatePackage.Literals.VARIABLE_DECLARATION__ANNOTATION));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getVariableDeclarationAccess().getNameIDTerminalRuleCall_1_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getVariableDeclarationAccess().getAnnotationBeanValidationAnnotationParserRuleCall_3_0(), semanticObject.getAnnotation());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     VoAddField returns VoAddField
	 *
	 * Constraint:
	 *     (properties=PropertyDeclaration annotationList+=JacksonAnnotation*)
	 * </pre>
	 */
	protected void sequence_VoAddField(ISerializationContext context, VoAddField semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     VoDefinition returns VoDefinition
	 *
	 * Constraint:
	 *     (
	 *         name=ID 
	 *         serializable='Serializable'? 
	 *         lombokAnnotation+=LombokAnnotation* 
	 *         (exclusions+=Exclusions+ | excludeAll=BOOL)? 
	 *         jacksons+=VoJackson* 
	 *         addField+=VoAddField*
	 *     )
	 * </pre>
	 */
	protected void sequence_VoDefinition(ISerializationContext context, VoDefinition semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     VoJackson returns VoJackson
	 *
	 * Constraint:
	 *     (field=[Field|QualifiedName] annList+=JacksonAnnotation*)
	 * </pre>
	 */
	protected void sequence_VoJackson(ISerializationContext context, VoJackson semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     GenerationRule returns VoRule
	 *     VoRule returns VoRule
	 *
	 * Constraint:
	 *     (model=[Model|ID] vos+=VoDefinition+)
	 * </pre>
	 */
	protected void sequence_VoRule(ISerializationContext context, VoRule semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
}
