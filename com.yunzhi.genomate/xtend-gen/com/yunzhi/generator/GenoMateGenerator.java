/**
 * generated by Xtext 2.38.0
 * 完成第一版 保存 后续用豆包优化
 */
package com.yunzhi.generator;

import com.google.common.collect.Iterables;
import com.yunzhi.genoMate.AndTypeCondition;
import com.yunzhi.genoMate.AnnotationParameters;
import com.yunzhi.genoMate.ArrayType;
import com.yunzhi.genoMate.BeanValidationAnnotation;
import com.yunzhi.genoMate.BeanValidationType;
import com.yunzhi.genoMate.BuiltInType;
import com.yunzhi.genoMate.DtoAddField;
import com.yunzhi.genoMate.DtoDefinition;
import com.yunzhi.genoMate.DtoRule;
import com.yunzhi.genoMate.DtoValidation;
import com.yunzhi.genoMate.Exclusions;
import com.yunzhi.genoMate.Field;
import com.yunzhi.genoMate.FieldAnnotation;
import com.yunzhi.genoMate.FieldValidationBlock;
import com.yunzhi.genoMate.GenerationRule;
import com.yunzhi.genoMate.GenericDataType;
import com.yunzhi.genoMate.GenoMate;
import com.yunzhi.genoMate.GlobalAction;
import com.yunzhi.genoMate.JacksonAnnotation;
import com.yunzhi.genoMate.JacksonType;
import com.yunzhi.genoMate.LocalAction;
import com.yunzhi.genoMate.LocalLoopAction;
import com.yunzhi.genoMate.LombokAnnotation;
import com.yunzhi.genoMate.LombokType;
import com.yunzhi.genoMate.Model;
import com.yunzhi.genoMate.MybatisPlusFieldAnnotation;
import com.yunzhi.genoMate.MybatisPlusFieldType;
import com.yunzhi.genoMate.MybatisPlusModelAnnotation;
import com.yunzhi.genoMate.MybatisPlusModelType;
import com.yunzhi.genoMate.NormalType;
import com.yunzhi.genoMate.OrTypeCondition;
import com.yunzhi.genoMate.Parameter;
import com.yunzhi.genoMate.PoAddField;
import com.yunzhi.genoMate.PoRule;
import com.yunzhi.genoMate.SimpleType;
import com.yunzhi.genoMate.Type;
import com.yunzhi.genoMate.TypeCondition;
import com.yunzhi.genoMate.TypeEqualityCondition;
import com.yunzhi.genoMate.VariableDeclaration;
import com.yunzhi.genoMate.VoAddField;
import com.yunzhi.genoMate.VoDefinition;
import com.yunzhi.genoMate.VoJackson;
import com.yunzhi.genoMate.VoRule;
import java.util.Arrays;
import java.util.Objects;
import java.util.Set;
import org.eclipse.emf.common.util.EList;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.resource.Resource;
import org.eclipse.xtend2.lib.StringConcatenation;
import org.eclipse.xtext.generator.AbstractGenerator;
import org.eclipse.xtext.generator.IFileSystemAccess2;
import org.eclipse.xtext.generator.IGeneratorContext;
import org.eclipse.xtext.xbase.lib.Functions.Function1;
import org.eclipse.xtext.xbase.lib.InputOutput;
import org.eclipse.xtext.xbase.lib.IterableExtensions;
import org.eclipse.xtext.xbase.lib.ListExtensions;
import org.eclipse.xtext.xbase.lib.StringExtensions;
import org.eclipse.xtext.xbase.lib.XbaseGenerated;

/**
 * Generates code from your model files on save.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#code-generation
 */
@SuppressWarnings("all")
public class GenoMateGenerator extends AbstractGenerator {
  @Override
  public void doGenerate(final Resource resource, final IFileSystemAccess2 fsa, final IGeneratorContext context) {
    EObject _head = IterableExtensions.<EObject>head(resource.getContents());
    final GenoMate model = ((GenoMate) _head);
    if ((model == null)) {
      InputOutput.<String>println("GenoMate is null!");
      return;
    }
    final EList<GenerationRule> rules = model.getGenerateSection().getRules();
    boolean _isEmpty = rules.isEmpty();
    if (_isEmpty) {
      InputOutput.<String>println("Rules list is empty!");
      return;
    }
    Iterable<PoRule> _filter = Iterables.<PoRule>filter(rules, PoRule.class);
    for (final PoRule rule : _filter) {
      {
        final String className = StringExtensions.toFirstUpper(rule.getModel().getName());
        final CharSequence poClassCode = this.toPOClass(rule);
        InputOutput.<String>println("========================================================================");
        InputOutput.<String>println((("Generated PO class code for " + className) + ": \n"));
        fsa.generateFile((className + ".java"), poClassCode);
      }
    }
    Iterable<DtoRule> _filter_1 = Iterables.<DtoRule>filter(rules, DtoRule.class);
    for (final DtoRule rule_1 : _filter_1) {
      {
        final Model md = rule_1.getModel();
        EList<DtoDefinition> _dtos = rule_1.getDtos();
        for (final DtoDefinition dto : _dtos) {
          {
            final String className = dto.getName();
            final CharSequence dtoClassCode = this.toDTOClass(dto, md);
            InputOutput.<String>println("========================================================================");
            InputOutput.<String>println((("Generated DTO class code for " + className) + ": \n"));
            fsa.generateFile((className + ".java"), dtoClassCode);
          }
        }
      }
    }
    Iterable<VoRule> _filter_2 = Iterables.<VoRule>filter(rules, VoRule.class);
    for (final VoRule rule_2 : _filter_2) {
      {
        final Model md = rule_2.getModel();
        EList<VoDefinition> _vos = rule_2.getVos();
        for (final VoDefinition vo : _vos) {
          {
            final String className = vo.getName();
            final CharSequence voClassCode = this.toVOClass(vo, md);
            InputOutput.<String>println("========================================================================");
            InputOutput.<String>println((("Generated VO class code for " + className) + ": \n"));
            fsa.generateFile((className + ".java"), voClassCode);
          }
        }
      }
    }
  }

  public CharSequence toPOClass(final PoRule rule) {
    StringConcatenation _builder = new StringConcatenation();
    {
      boolean _isNullOrEmpty = IterableExtensions.isNullOrEmpty(rule.getLombokAnnotation());
      boolean _not = (!_isNullOrEmpty);
      if (_not) {
        final Function1<LombokAnnotation, String> _function = (LombokAnnotation it) -> {
          return this.toAnnotationString(it);
        };
        String _join = IterableExtensions.join(ListExtensions.<LombokAnnotation, String>map(rule.getLombokAnnotation(), _function), "\n");
        _builder.append(_join);
        _builder.newLineIfNotEmpty();
      }
    }
    {
      boolean _isNullOrEmpty_1 = IterableExtensions.isNullOrEmpty(rule.getMybatisPlusModelAnnotation());
      boolean _not_1 = (!_isNullOrEmpty_1);
      if (_not_1) {
        final Function1<MybatisPlusModelAnnotation, String> _function_1 = (MybatisPlusModelAnnotation it) -> {
          return this.toAnnotationString(it);
        };
        String _join_1 = IterableExtensions.join(ListExtensions.<MybatisPlusModelAnnotation, String>map(rule.getMybatisPlusModelAnnotation(), _function_1), "\n");
        _builder.append(_join_1);
        _builder.newLineIfNotEmpty();
      }
    }
    _builder.append("public class ");
    String _firstUpper = StringExtensions.toFirstUpper(rule.getModel().getName());
    _builder.append(_firstUpper);
    _builder.append(" ");
    {
      String _serializable = rule.getSerializable();
      boolean _equals = Objects.equals(_serializable, "true");
      if (_equals) {
        _builder.append("implements Serializable ");
      }
    }
    _builder.append(" {");
    _builder.newLineIfNotEmpty();
    _builder.append("\t");
    _builder.newLine();
    {
      EList<Field> _fields = rule.getModel().getFields();
      for(final Field currentfield : _fields) {
        {
          final Function1<FieldAnnotation, Boolean> _function_2 = (FieldAnnotation it) -> {
            String _name = it.getField().getName();
            String _name_1 = currentfield.getName();
            return Boolean.valueOf(Objects.equals(_name, _name_1));
          };
          boolean _exists = IterableExtensions.<FieldAnnotation>exists(rule.getFieldAnns(), _function_2);
          if (_exists) {
            final Function1<FieldAnnotation, Boolean> _function_3 = (FieldAnnotation it) -> {
              String _name = it.getField().getName();
              String _name_1 = currentfield.getName();
              return Boolean.valueOf(Objects.equals(_name, _name_1));
            };
            final Function1<MybatisPlusFieldAnnotation, String> _function_4 = (MybatisPlusFieldAnnotation it) -> {
              return this.toAnnotationString(it);
            };
            String _join_2 = IterableExtensions.join(ListExtensions.<MybatisPlusFieldAnnotation, String>map(IterableExtensions.<FieldAnnotation>findFirst(rule.getFieldAnns(), _function_3).getAnnList(), _function_4), "\n");
            _builder.append(_join_2);
            _builder.newLineIfNotEmpty();
          }
        }
        _builder.append("    ");
        _builder.append("private ");
        String _typeName = this.getTypeName(currentfield.getType());
        _builder.append(_typeName, "    ");
        _builder.append(" ");
        String _name = currentfield.getName();
        _builder.append(_name, "    ");
        _builder.append(";");
        _builder.newLineIfNotEmpty();
        _builder.append("    ");
        _builder.newLine();
      }
    }
    {
      EList<PoAddField> _addField = rule.getAddField();
      for(final PoAddField currentfield_1 : _addField) {
        final Function1<MybatisPlusFieldAnnotation, String> _function_5 = (MybatisPlusFieldAnnotation it) -> {
          return this.toAnnotationString(it);
        };
        String _join_3 = IterableExtensions.join(ListExtensions.<MybatisPlusFieldAnnotation, String>map(currentfield_1.getAnnotationList(), _function_5), "\n");
        _builder.append(_join_3);
        _builder.newLineIfNotEmpty();
        _builder.append("\t");
        _builder.append("private ");
        String _typeName_1 = this.getTypeName(currentfield_1.getProperties().getType());
        _builder.append(_typeName_1, "\t");
        _builder.append(" ");
        String _name_1 = currentfield_1.getProperties().getName();
        _builder.append(_name_1, "\t");
        {
          boolean _isNullOrEmpty_2 = StringExtensions.isNullOrEmpty(currentfield_1.getProperties().getDefaultClause());
          boolean _not_2 = (!_isNullOrEmpty_2);
          if (_not_2) {
            _builder.append(" ");
            String _defaultClause = currentfield_1.getProperties().getDefaultClause();
            _builder.append(_defaultClause, "\t");
          }
        }
        _builder.append(";");
        _builder.newLineIfNotEmpty();
        _builder.append("    ");
        _builder.newLine();
      }
    }
    {
      String _serializable_1 = rule.getSerializable();
      boolean _equals_1 = Objects.equals(_serializable_1, "true");
      if (_equals_1) {
        _builder.append("    ");
        _builder.append("@TableField(exist = false)");
        _builder.newLine();
        _builder.append("    ");
        _builder.append("private static final long serialVersionUID = 1L;");
        _builder.newLine();
        _builder.append("    ");
        _builder.newLine();
      }
    }
    _builder.append("}");
    _builder.newLine();
    return _builder;
  }

  public CharSequence toDTOClass(final DtoDefinition rule, final Model model) {
    StringConcatenation _builder = new StringConcatenation();
    {
      boolean _isNullOrEmpty = IterableExtensions.isNullOrEmpty(rule.getLombokAnnotation());
      boolean _not = (!_isNullOrEmpty);
      if (_not) {
        final Function1<LombokAnnotation, String> _function = (LombokAnnotation it) -> {
          return this.toAnnotationString(it);
        };
        String _join = IterableExtensions.join(ListExtensions.<LombokAnnotation, String>map(rule.getLombokAnnotation(), _function), "\n");
        _builder.append(_join);
        _builder.newLineIfNotEmpty();
      }
    }
    _builder.append("public class ");
    String _firstUpper = StringExtensions.toFirstUpper(rule.getName());
    _builder.append(_firstUpper);
    _builder.append(" ");
    {
      String _serializable = rule.getSerializable();
      boolean _equals = Objects.equals(_serializable, "true");
      if (_equals) {
        _builder.append("implements Serializable ");
      }
    }
    _builder.append("{");
    _builder.newLineIfNotEmpty();
    _builder.append("\t");
    _builder.newLine();
    {
      String _excludeAll = rule.getExcludeAll();
      boolean _notEquals = (!Objects.equals(_excludeAll, "true"));
      if (_notEquals) {
        final Function1<Exclusions, String> _function_1 = (Exclusions it) -> {
          return it.getField().getName();
        };
        final Set<String> excludeNames = IterableExtensions.<String>toSet(ListExtensions.<Exclusions, String>map(rule.getExclusions(), _function_1));
        _builder.newLineIfNotEmpty();
        {
          final Function1<Field, Boolean> _function_2 = (Field it) -> {
            boolean _contains = excludeNames.contains(it.getName());
            return Boolean.valueOf((!_contains));
          };
          Iterable<Field> _filter = IterableExtensions.<Field>filter(model.getFields(), _function_2);
          for(final Field currentfield : _filter) {
            {
              FieldValidationBlock _fieldAnnotationsBlock = rule.getFieldAnnotationsBlock();
              boolean _tripleNotEquals = (_fieldAnnotationsBlock != null);
              if (_tripleNotEquals) {
                {
                  if (((rule.getFieldAnnotationsBlock().getActionGlobal() != null) && (!IterableExtensions.isNullOrEmpty(rule.getFieldAnnotationsBlock().getActionGlobal())))) {
                    final Function1<GlobalAction, BeanValidationAnnotation> _function_3 = (GlobalAction it) -> {
                      return it.getVariable().getAnnotation();
                    };
                    final Function1<BeanValidationAnnotation, String> _function_4 = (BeanValidationAnnotation it) -> {
                      return this.toAnnotationString(it);
                    };
                    String _join_1 = IterableExtensions.join(IterableExtensions.<BeanValidationAnnotation, String>map(IterableExtensions.<BeanValidationAnnotation>filterNull(ListExtensions.<GlobalAction, BeanValidationAnnotation>map(rule.getFieldAnnotationsBlock().getActionGlobal(), _function_3)), _function_4), "\n");
                    _builder.append(_join_1);
                    _builder.newLineIfNotEmpty();
                  }
                }
                {
                  if (((rule.getFieldAnnotationsBlock().getActionLocal() != null) && (!IterableExtensions.isNullOrEmpty(rule.getFieldAnnotationsBlock().getActionLocal())))) {
                    {
                      EList<LocalLoopAction> _actionLocal = rule.getFieldAnnotationsBlock().getActionLocal();
                      for(final LocalLoopAction loop : _actionLocal) {
                        {
                          boolean _isNullOrEmpty_1 = IterableExtensions.isNullOrEmpty(loop.getActions());
                          boolean _not_1 = (!_isNullOrEmpty_1);
                          if (_not_1) {
                            {
                              EList<LocalAction> _actions = loop.getActions();
                              for(final LocalAction action : _actions) {
                                {
                                  Boolean _evaluateCondition = this.evaluateCondition(action.getCondition(), currentfield.getType());
                                  if ((_evaluateCondition).booleanValue()) {
                                    final Function1<VariableDeclaration, BeanValidationAnnotation> _function_5 = (VariableDeclaration it) -> {
                                      return it.getAnnotation();
                                    };
                                    final Function1<BeanValidationAnnotation, String> _function_6 = (BeanValidationAnnotation it) -> {
                                      return this.toAnnotationString(it);
                                    };
                                    String _join_2 = IterableExtensions.join(IterableExtensions.<BeanValidationAnnotation, String>map(IterableExtensions.<BeanValidationAnnotation>filterNull(ListExtensions.<VariableDeclaration, BeanValidationAnnotation>map(loop.getVarDeclarations(), _function_5)), _function_6), "\n");
                                    _builder.append(_join_2);
                                    _builder.newLineIfNotEmpty();
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
                {
                  if (((rule.getFieldAnnotationsBlock().getActionSingle() != null) && IterableExtensions.<DtoValidation>exists(rule.getFieldAnnotationsBlock().getActionSingle().getValidations(), ((Function1<DtoValidation, Boolean>) (DtoValidation it) -> {
                    Field _field = it.getField();
                    String _name = currentfield.getName();
                    return Boolean.valueOf(Objects.equals(_field, _name));
                  })))) {
                    final Function1<DtoValidation, Boolean> _function_7 = (DtoValidation it) -> {
                      Field _field = it.getField();
                      String _name = currentfield.getName();
                      return Boolean.valueOf(Objects.equals(_field, _name));
                    };
                    final Function1<BeanValidationAnnotation, String> _function_8 = (BeanValidationAnnotation it) -> {
                      return this.toAnnotationString(it);
                    };
                    String _join_3 = IterableExtensions.join(ListExtensions.<BeanValidationAnnotation, String>map(IterableExtensions.<DtoValidation>findFirst(rule.getFieldAnnotationsBlock().getActionSingle().getValidations(), _function_7).getAnnList(), _function_8), "\n");
                    _builder.append(_join_3);
                    _builder.newLineIfNotEmpty();
                  }
                }
              }
            }
            _builder.append("\t");
            _builder.append("private ");
            String _typeName = this.getTypeName(currentfield.getType());
            _builder.append(_typeName, "\t");
            _builder.append(" ");
            String _name = currentfield.getName();
            _builder.append(_name, "\t");
            _builder.append(";");
            _builder.newLineIfNotEmpty();
            _builder.newLine();
          }
        }
      }
    }
    {
      EList<DtoAddField> _addField = rule.getAddField();
      for(final DtoAddField currentfield_1 : _addField) {
        final Function1<BeanValidationAnnotation, String> _function_9 = (BeanValidationAnnotation it) -> {
          return this.toAnnotationString(it);
        };
        String _join_4 = IterableExtensions.join(ListExtensions.<BeanValidationAnnotation, String>map(currentfield_1.getAnnotationList(), _function_9), "\n");
        _builder.append(_join_4);
        _builder.newLineIfNotEmpty();
        _builder.append("\t");
        _builder.append("private ");
        String _typeName_1 = this.getTypeName(currentfield_1.getProperties().getType());
        _builder.append(_typeName_1, "\t");
        _builder.append(" ");
        String _name_1 = currentfield_1.getProperties().getName();
        _builder.append(_name_1, "\t");
        {
          boolean _isNullOrEmpty_2 = StringExtensions.isNullOrEmpty(currentfield_1.getProperties().getDefaultClause());
          boolean _not_2 = (!_isNullOrEmpty_2);
          if (_not_2) {
            _builder.append(" ");
            String _defaultClause = currentfield_1.getProperties().getDefaultClause();
            _builder.append(_defaultClause, "\t");
          }
        }
        _builder.append(";");
        _builder.newLineIfNotEmpty();
        _builder.append("\t");
        _builder.newLine();
      }
    }
    {
      String _serializable_1 = rule.getSerializable();
      boolean _equals_1 = Objects.equals(_serializable_1, "true");
      if (_equals_1) {
        _builder.append("    ");
        _builder.append("@TableField(exist = false)");
        _builder.newLine();
        _builder.append("    ");
        _builder.append("private static final long serialVersionUID = 1L;");
        _builder.newLine();
        _builder.append("    ");
        _builder.newLine();
      }
    }
    _builder.append("}");
    _builder.newLine();
    return _builder;
  }

  public CharSequence toVOClass(final VoDefinition rule, final Model model) {
    StringConcatenation _builder = new StringConcatenation();
    {
      boolean _isNullOrEmpty = IterableExtensions.isNullOrEmpty(rule.getLombokAnnotation());
      boolean _not = (!_isNullOrEmpty);
      if (_not) {
        final Function1<LombokAnnotation, String> _function = (LombokAnnotation it) -> {
          return this.toAnnotationString(it);
        };
        String _join = IterableExtensions.join(ListExtensions.<LombokAnnotation, String>map(rule.getLombokAnnotation(), _function), "\n");
        _builder.append(_join);
        _builder.newLineIfNotEmpty();
      }
    }
    _builder.append("public class ");
    String _firstUpper = StringExtensions.toFirstUpper(rule.getName());
    _builder.append(_firstUpper);
    _builder.append(" ");
    {
      String _serializable = rule.getSerializable();
      boolean _equals = Objects.equals(_serializable, "true");
      if (_equals) {
        _builder.append("implements Serializable ");
      }
    }
    _builder.append("{");
    _builder.newLineIfNotEmpty();
    _builder.append("\t");
    _builder.newLine();
    {
      String _excludeAll = rule.getExcludeAll();
      boolean _notEquals = (!Objects.equals(_excludeAll, "true"));
      if (_notEquals) {
        _builder.append("    ");
        final Function1<Exclusions, String> _function_1 = (Exclusions it) -> {
          return it.getField().getName();
        };
        final Set<String> excludeNames = IterableExtensions.<String>toSet(ListExtensions.<Exclusions, String>map(rule.getExclusions(), _function_1));
        _builder.newLineIfNotEmpty();
        {
          final Function1<Field, Boolean> _function_2 = (Field it) -> {
            boolean _contains = excludeNames.contains(it.getName());
            return Boolean.valueOf((!_contains));
          };
          Iterable<Field> _filter = IterableExtensions.<Field>filter(model.getFields(), _function_2);
          for(final Field currentfield : _filter) {
            {
              final Function1<VoJackson, Boolean> _function_3 = (VoJackson it) -> {
                String _name = it.getField().getName();
                String _name_1 = currentfield.getName();
                return Boolean.valueOf(Objects.equals(_name, _name_1));
              };
              boolean _exists = IterableExtensions.<VoJackson>exists(rule.getJacksons(), _function_3);
              if (_exists) {
                final Function1<VoJackson, Boolean> _function_4 = (VoJackson it) -> {
                  String _name = it.getField().getName();
                  String _name_1 = currentfield.getName();
                  return Boolean.valueOf(Objects.equals(_name, _name_1));
                };
                final Function1<JacksonAnnotation, String> _function_5 = (JacksonAnnotation it) -> {
                  return this.toAnnotationString(it);
                };
                String _join_1 = IterableExtensions.join(ListExtensions.<JacksonAnnotation, String>map(IterableExtensions.<VoJackson>findFirst(rule.getJacksons(), _function_4).getAnnList(), _function_5), "\n");
                _builder.append(_join_1);
                _builder.newLineIfNotEmpty();
              }
            }
            _builder.append("    ");
            _builder.append("private ");
            String _typeName = this.getTypeName(currentfield.getType());
            _builder.append(_typeName, "    ");
            _builder.append(" ");
            String _name = currentfield.getName();
            _builder.append(_name, "    ");
            _builder.append(";");
            _builder.newLineIfNotEmpty();
            _builder.append("    ");
            _builder.newLine();
          }
        }
      }
    }
    {
      EList<VoAddField> _addField = rule.getAddField();
      for(final VoAddField currentfield_1 : _addField) {
        _builder.append("    ");
        final Function1<JacksonAnnotation, String> _function_6 = (JacksonAnnotation it) -> {
          return this.toAnnotationString(it);
        };
        String _join_2 = IterableExtensions.join(ListExtensions.<JacksonAnnotation, String>map(currentfield_1.getAnnotationList(), _function_6), "\n");
        _builder.append(_join_2, "    ");
        _builder.newLineIfNotEmpty();
        _builder.append("    ");
        _builder.append("private ");
        String _typeName_1 = this.getTypeName(currentfield_1.getProperties().getType());
        _builder.append(_typeName_1, "    ");
        _builder.append(" ");
        String _name_1 = currentfield_1.getProperties().getName();
        _builder.append(_name_1, "    ");
        {
          boolean _isNullOrEmpty_1 = StringExtensions.isNullOrEmpty(currentfield_1.getProperties().getDefaultClause());
          boolean _not_1 = (!_isNullOrEmpty_1);
          if (_not_1) {
            _builder.append(" ");
            String _defaultClause = currentfield_1.getProperties().getDefaultClause();
            _builder.append(_defaultClause, "    ");
          }
        }
        _builder.append(";");
        _builder.newLineIfNotEmpty();
        _builder.append("    ");
        _builder.newLine();
      }
    }
    {
      String _serializable_1 = rule.getSerializable();
      boolean _equals_1 = Objects.equals(_serializable_1, "true");
      if (_equals_1) {
        _builder.append("    ");
        _builder.append("@TableField(exist = false)");
        _builder.newLine();
        _builder.append("    ");
        _builder.append("private static final long serialVersionUID = 1L;");
        _builder.newLine();
        _builder.append("    ");
        _builder.newLine();
      }
    }
    _builder.append("}");
    _builder.newLine();
    return _builder;
  }

  protected String _getTypeName(final NormalType type) {
    InputOutput.<String>println("NormalType");
    return type.getCustomType();
  }

  protected String _getTypeName(final SimpleType type) {
    String _literal = type.getBuiltInType().getLiteral();
    String _plus = ("BuiltInType: " + _literal);
    InputOutput.<String>println(_plus);
    return type.getBuiltInType().getLiteral();
  }

  protected String _getTypeName(final ArrayType type) {
    InputOutput.<String>println("ArrayType");
    String _typeName = this.getTypeName(type.getElementType());
    return (_typeName + "[]");
  }

  protected String _getTypeName(final GenericDataType type) {
    InputOutput.<String>println("GenericDataType");
    String _containerTypeName = type.getContainerTypeName();
    String _plus = (_containerTypeName + "<");
    String _typeName = this.getTypeName(type.getContainedTypeName());
    String _plus_1 = (_plus + _typeName);
    return (_plus_1 + ">");
  }

  public String toAnnotationString(final LombokAnnotation annotation) {
    String _xifexpression = null;
    AnnotationParameters _parameters = annotation.getParameters();
    boolean _tripleNotEquals = (_parameters != null);
    if (_tripleNotEquals) {
      StringConcatenation _builder = new StringConcatenation();
      _builder.append("@");
      LombokType _name = annotation.getName();
      _builder.append(_name);
      _builder.append("(");
      final Function1<Parameter, String> _function = (Parameter it) -> {
        String _key = it.getKey();
        String _plus = (_key + " = ");
        String _value = it.getValue();
        return (_plus + _value);
      };
      String _join = IterableExtensions.join(ListExtensions.<Parameter, String>map(annotation.getParameters().getAnnparameters(), _function), ", ");
      _builder.append(_join);
      _builder.append(")");
      _xifexpression = _builder.toString();
    } else {
      StringConcatenation _builder_1 = new StringConcatenation();
      _builder_1.append("@");
      LombokType _name_1 = annotation.getName();
      _builder_1.append(_name_1);
      _xifexpression = _builder_1.toString();
    }
    return _xifexpression;
  }

  public String toAnnotationString(final MybatisPlusModelAnnotation annotation) {
    String _xifexpression = null;
    AnnotationParameters _parameters = annotation.getParameters();
    boolean _tripleNotEquals = (_parameters != null);
    if (_tripleNotEquals) {
      StringConcatenation _builder = new StringConcatenation();
      _builder.append("@");
      MybatisPlusModelType _name = annotation.getName();
      _builder.append(_name);
      _builder.append("(");
      final Function1<Parameter, String> _function = (Parameter it) -> {
        String _key = it.getKey();
        String _plus = (_key + " = ");
        String _value = it.getValue();
        return (_plus + _value);
      };
      String _join = IterableExtensions.join(ListExtensions.<Parameter, String>map(annotation.getParameters().getAnnparameters(), _function), ", ");
      _builder.append(_join);
      _builder.append(")");
      _xifexpression = _builder.toString();
    } else {
      StringConcatenation _builder_1 = new StringConcatenation();
      _builder_1.append("@");
      MybatisPlusModelType _name_1 = annotation.getName();
      _builder_1.append(_name_1);
      _xifexpression = _builder_1.toString();
    }
    return _xifexpression;
  }

  public String toAnnotationString(final MybatisPlusFieldAnnotation annotation) {
    String _xifexpression = null;
    AnnotationParameters _parameters = annotation.getParameters();
    boolean _tripleNotEquals = (_parameters != null);
    if (_tripleNotEquals) {
      StringConcatenation _builder = new StringConcatenation();
      _builder.append("\t");
      _builder.append("@");
      MybatisPlusFieldType _name = annotation.getName();
      _builder.append(_name, "\t");
      _builder.append("(");
      final Function1<Parameter, String> _function = (Parameter it) -> {
        String _key = it.getKey();
        String _plus = (_key + " = ");
        String _value = it.getValue();
        return (_plus + _value);
      };
      String _join = IterableExtensions.join(ListExtensions.<Parameter, String>map(annotation.getParameters().getAnnparameters(), _function), ", ");
      _builder.append(_join, "\t");
      _builder.append(")");
      _xifexpression = _builder.toString();
    } else {
      StringConcatenation _builder_1 = new StringConcatenation();
      _builder_1.append("\t");
      _builder_1.append("@");
      MybatisPlusFieldType _name_1 = annotation.getName();
      _builder_1.append(_name_1, "\t");
      _xifexpression = _builder_1.toString();
    }
    return _xifexpression;
  }

  public String toAnnotationString(final JacksonAnnotation annotation) {
    String _xifexpression = null;
    AnnotationParameters _parameters = annotation.getParameters();
    boolean _tripleNotEquals = (_parameters != null);
    if (_tripleNotEquals) {
      StringConcatenation _builder = new StringConcatenation();
      _builder.append("\t");
      _builder.append("@");
      JacksonType _name = annotation.getName();
      _builder.append(_name, "\t");
      _builder.append("(");
      final Function1<Parameter, String> _function = (Parameter it) -> {
        String _key = it.getKey();
        String _plus = (_key + " = ");
        String _value = it.getValue();
        return (_plus + _value);
      };
      String _join = IterableExtensions.join(ListExtensions.<Parameter, String>map(annotation.getParameters().getAnnparameters(), _function), ", ");
      _builder.append(_join, "\t");
      _builder.append(")");
      _xifexpression = _builder.toString();
    } else {
      StringConcatenation _builder_1 = new StringConcatenation();
      _builder_1.append("\t");
      _builder_1.append("@");
      JacksonType _name_1 = annotation.getName();
      _builder_1.append(_name_1, "\t");
      _xifexpression = _builder_1.toString();
    }
    return _xifexpression;
  }

  public String toAnnotationString(final BeanValidationAnnotation annotation) {
    String _xifexpression = null;
    AnnotationParameters _parameters = annotation.getParameters();
    boolean _tripleNotEquals = (_parameters != null);
    if (_tripleNotEquals) {
      StringConcatenation _builder = new StringConcatenation();
      _builder.append("\t");
      _builder.append("@");
      BeanValidationType _name = annotation.getName();
      _builder.append(_name, "\t");
      _builder.append("(");
      final Function1<Parameter, String> _function = (Parameter it) -> {
        String _key = it.getKey();
        String _plus = (_key + " = ");
        String _value = it.getValue();
        return (_plus + _value);
      };
      String _join = IterableExtensions.join(ListExtensions.<Parameter, String>map(annotation.getParameters().getAnnparameters(), _function), ", ");
      _builder.append(_join, "\t");
      _builder.append(")");
      _xifexpression = _builder.toString();
    } else {
      StringConcatenation _builder_1 = new StringConcatenation();
      _builder_1.append("\t");
      _builder_1.append("@");
      BeanValidationType _name_1 = annotation.getName();
      _builder_1.append(_name_1, "\t");
      _xifexpression = _builder_1.toString();
    }
    return _xifexpression;
  }

  public String toString(final Parameter param) {
    StringConcatenation _builder = new StringConcatenation();
    String _key = param.getKey();
    _builder.append(_key);
    _builder.append(" = ");
    String _value = param.getValue();
    _builder.append(_value);
    return _builder.toString();
  }

  public Boolean evaluateCondition(final TypeCondition condition, final Type type) {
    InputOutput.<String>println("\n****************************************************");
    InputOutput.<String>println(("\n开始评估条件: ===== 当前Type: " + type));
    Boolean result = this.evaluateOrCondition(((OrTypeCondition) condition), type);
    InputOutput.<String>println(("条件评估结果: " + result));
    return result;
  }

  private Boolean evaluateOrCondition(final OrTypeCondition condition, final Type type) {
    InputOutput.<String>println("\n开始评估 OR 条件: ");
    Boolean leftResult = this.evaluateAndCondition(condition.getLeft(), type);
    InputOutput.<String>println(("OR 条件左部分结果: " + leftResult));
    if ((leftResult).booleanValue()) {
      InputOutput.<String>println("OR 条件因左部分为 true 直接返回 true");
      return Boolean.valueOf(true);
    }
    EList<AndTypeCondition> _right = condition.getRight();
    for (final AndTypeCondition rightCondition : _right) {
      {
        Boolean rightResult = this.evaluateAndCondition(rightCondition, type);
        InputOutput.<String>println(((("OR 条件右部分 " + rightCondition) + " 结果: ") + rightResult));
        if ((rightResult).booleanValue()) {
          InputOutput.<String>println("OR 条件因右部分为 true 返回 true");
          return Boolean.valueOf(true);
        }
      }
    }
    InputOutput.<String>println("OR 条件所有部分都为 false，返回 false");
    return Boolean.valueOf(false);
  }

  private Boolean evaluateAndCondition(final AndTypeCondition condition, final Type type) {
    InputOutput.<String>println("\n开始评估 AND 条件: ");
    Boolean leftResult = this.evaluateEqualityCondition(condition.getLeft(), type);
    InputOutput.<String>println(("AND 条件左部分结果: " + leftResult));
    if ((!(leftResult).booleanValue())) {
      InputOutput.<String>println("AND 条件因左部分为 false 直接返回 false");
      return Boolean.valueOf(false);
    }
    EList<TypeEqualityCondition> _right = condition.getRight();
    for (final TypeEqualityCondition rightCondition : _right) {
      {
        Boolean rightResult = this.evaluateEqualityCondition(rightCondition, type);
        InputOutput.<String>println(((("AND 条件右部分 " + rightCondition) + " 结果: ") + rightResult));
        if ((!(rightResult).booleanValue())) {
          InputOutput.<String>println("AND 条件因右部分为 false 返回 false");
          return Boolean.valueOf(false);
        }
      }
    }
    InputOutput.<String>println("AND 条件所有部分都为 true，返回 true");
    return Boolean.valueOf(true);
  }

  private Boolean evaluateEqualityCondition(final TypeEqualityCondition condition, final Type type) {
    InputOutput.<String>println("\n开始评估相等条件: ");
    final Type targetType = condition.getType();
    InputOutput.<String>println(((("targetType: " + targetType) + " === type: ") + type));
    String _isEqual = condition.getIsEqual();
    String _plus = ("condition.isEqual: " + _isEqual);
    String _plus_1 = (_plus + " | condition.isNotEqual: ");
    String _isNotEqual = condition.getIsNotEqual();
    String _plus_2 = (_plus_1 + _isNotEqual);
    InputOutput.<String>println(_plus_2);
    String _isEqual_1 = condition.getIsEqual();
    final boolean isEqualCondition = (_isEqual_1 != null);
    InputOutput.<String>println(("是否为相等条件: " + Boolean.valueOf(isEqualCondition)));
    boolean _xifexpression = false;
    if (isEqualCondition) {
      _xifexpression = GenoMateGenerator.isTypeEqual(type, targetType);
    } else {
      boolean _isTypeEqual = GenoMateGenerator.isTypeEqual(type, targetType);
      _xifexpression = (!_isTypeEqual);
    }
    final boolean result = _xifexpression;
    InputOutput.<String>println(("评估结果: " + Boolean.valueOf(result)));
    return Boolean.valueOf(result);
  }

  public static boolean isTypeEqual(final Type t1, final Type t2) {
    if ((t1 == t2)) {
      InputOutput.<String>println("类型相同（同一实例）：true");
      return true;
    }
    if (((t1 == null) || (t2 == null))) {
      InputOutput.<String>println("其中一个类型为 null：false");
      return false;
    }
    InputOutput.<String>println("\n比较类型：");
    String _simpleName = t1.getClass().getSimpleName();
    String _plus = ("t1: " + _simpleName);
    String _plus_1 = (_plus + " -> ");
    String _plus_2 = (_plus_1 + t1);
    InputOutput.<String>println(_plus_2);
    String _simpleName_1 = t2.getClass().getSimpleName();
    String _plus_3 = ("t2: " + _simpleName_1);
    String _plus_4 = (_plus_3 + " -> ");
    String _plus_5 = (_plus_4 + t2);
    InputOutput.<String>println(_plus_5);
    boolean _switchResult = false;
    boolean _matched = false;
    if (t1 instanceof SimpleType) {
      _matched=true;
      boolean _xifexpression = false;
      if ((t2 instanceof SimpleType)) {
        boolean _xblockexpression = false;
        {
          InputOutput.<String>println("比较 SimpleType：");
          BuiltInType _builtInType = ((SimpleType)t1).getBuiltInType();
          String _plus_6 = ("t1.builtInType: " + _builtInType);
          InputOutput.<String>println(_plus_6);
          BuiltInType _builtInType_1 = ((SimpleType)t2).getBuiltInType();
          String _plus_7 = ("t2.builtInType: " + _builtInType_1);
          InputOutput.<String>println(_plus_7);
          BuiltInType _builtInType_2 = ((SimpleType)t1).getBuiltInType();
          BuiltInType _builtInType_3 = ((SimpleType)t2).getBuiltInType();
          _xblockexpression = Objects.equals(_builtInType_2, _builtInType_3);
        }
        _xifexpression = _xblockexpression;
      } else {
        boolean _xblockexpression_1 = false;
        {
          InputOutput.<String>println("t2 不是 SimpleType：false");
          _xblockexpression_1 = false;
        }
        _xifexpression = _xblockexpression_1;
      }
      _switchResult = _xifexpression;
    }
    if (!_matched) {
      if (t1 instanceof NormalType) {
        _matched=true;
        boolean _xifexpression = false;
        if ((t2 instanceof NormalType)) {
          boolean _xblockexpression = false;
          {
            InputOutput.<String>println("比较 NormalType：");
            String _customType = ((NormalType)t1).getCustomType();
            String _plus_6 = ("t1.customType: " + _customType);
            InputOutput.<String>println(_plus_6);
            String _customType_1 = ((NormalType)t2).getCustomType();
            String _plus_7 = ("t2.customType: " + _customType_1);
            InputOutput.<String>println(_plus_7);
            String _customType_2 = ((NormalType)t1).getCustomType();
            String _customType_3 = ((NormalType)t2).getCustomType();
            _xblockexpression = Objects.equals(_customType_2, _customType_3);
          }
          _xifexpression = _xblockexpression;
        } else {
          boolean _xblockexpression_1 = false;
          {
            InputOutput.<String>println("t2 不是 NormalType：false");
            _xblockexpression_1 = false;
          }
          _xifexpression = _xblockexpression_1;
        }
        _switchResult = _xifexpression;
      }
    }
    if (!_matched) {
      if (t1 instanceof ArrayType) {
        _matched=true;
        boolean _xifexpression = false;
        if ((t2 instanceof ArrayType)) {
          boolean _xblockexpression = false;
          {
            InputOutput.<String>println("比较 ArrayType：");
            Type _elementType = ((ArrayType)t1).getElementType();
            String _plus_6 = ("t1.elementType: " + _elementType);
            InputOutput.<String>println(_plus_6);
            Type _elementType_1 = ((ArrayType)t2).getElementType();
            String _plus_7 = ("t2.elementType: " + _elementType_1);
            InputOutput.<String>println(_plus_7);
            _xblockexpression = GenoMateGenerator.isTypeEqual(((ArrayType)t1).getElementType(), ((ArrayType)t2).getElementType());
          }
          _xifexpression = _xblockexpression;
        } else {
          boolean _xblockexpression_1 = false;
          {
            InputOutput.<String>println("t2 不是 ArrayType：false");
            _xblockexpression_1 = false;
          }
          _xifexpression = _xblockexpression_1;
        }
        _switchResult = _xifexpression;
      }
    }
    if (!_matched) {
      if (t1 instanceof GenericDataType) {
        _matched=true;
        boolean _xifexpression = false;
        if ((t2 instanceof GenericDataType)) {
          boolean _xblockexpression = false;
          {
            InputOutput.<String>println("比较 GenericDataType：");
            String _containerTypeName = ((GenericDataType)t1).getContainerTypeName();
            String _plus_6 = ("t1.containerTypeName: " + _containerTypeName);
            InputOutput.<String>println(_plus_6);
            String _containerTypeName_1 = ((GenericDataType)t2).getContainerTypeName();
            String _plus_7 = ("t2.containerTypeName: " + _containerTypeName_1);
            InputOutput.<String>println(_plus_7);
            Type _containedTypeName = ((GenericDataType)t1).getContainedTypeName();
            String _plus_8 = ("t1.containedTypeName: " + _containedTypeName);
            InputOutput.<String>println(_plus_8);
            Type _containedTypeName_1 = ((GenericDataType)t2).getContainedTypeName();
            String _plus_9 = ("t2.containedTypeName: " + _containedTypeName_1);
            InputOutput.<String>println(_plus_9);
            _xblockexpression = (Objects.equals(((GenericDataType)t1).getContainerTypeName(), ((GenericDataType)t2).getContainerTypeName()) && 
              GenoMateGenerator.isTypeEqual(((GenericDataType)t1).getContainedTypeName(), ((GenericDataType)t2).getContainedTypeName()));
          }
          _xifexpression = _xblockexpression;
        } else {
          boolean _xblockexpression_1 = false;
          {
            InputOutput.<String>println("t2 不是 GenericDataType：false");
            _xblockexpression_1 = false;
          }
          _xifexpression = _xblockexpression_1;
        }
        _switchResult = _xifexpression;
      }
    }
    if (!_matched) {
      boolean _xblockexpression = false;
      {
        InputOutput.<String>println("未知类型：false");
        _xblockexpression = false;
      }
      _switchResult = _xblockexpression;
    }
    final boolean result = _switchResult;
    InputOutput.<String>println(("比较结果：" + Boolean.valueOf(result)));
    return result;
  }

  @XbaseGenerated
  public String getTypeName(final Type type) {
    if (type instanceof ArrayType) {
      return _getTypeName((ArrayType)type);
    } else if (type instanceof GenericDataType) {
      return _getTypeName((GenericDataType)type);
    } else if (type instanceof NormalType) {
      return _getTypeName((NormalType)type);
    } else if (type instanceof SimpleType) {
      return _getTypeName((SimpleType)type);
    } else {
      throw new IllegalArgumentException("Unhandled parameter types: " +
        Arrays.<Object>asList(type).toString());
    }
  }
}
